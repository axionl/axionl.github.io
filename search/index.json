[{"content":"前言  项目地址: axionl/OhMyQt\n  项目在 Windows 11 和 ArchLinux 下进行测试 Qt 版本: 5.15.2  本文以项目构建的角度介绍一个简单 Qt 应用的开发，其余具体的环境安装和配置稍后会在第 0 节内容中放出。\n从看见到设计 我们需要一个简单的展示页面作为上手的第一个项目：\n 一个醒目的标题 一段用于描述的文字 还有一个好看的背景  假设我们已经做了出来，它长下面这个样子，你需要做的是把它保留在你的想象中，我们再回过头来考虑如何实现。\n preview \n布局 我们把窗口想象成一个盒子（而不是一个平面或者一张桌子，因为盒子横看有四壁，俯瞰有纵深），而所需要填入的内容当成另一个小些的盒子，套入到窗口这个大盒子中。结合我们多年糊 PPT 的水平，可以对界面有如下设计要求：\n 内容整体居中 标题和描述上下排布 内容之间最好有一定的间距   layout \n如上图所示，我们把这一些要求的集合称为 “布局” 也即 Layout，它决定了我们软件设计的基本框架。上面的每一项具体内容称为 “元素” 即 Element / Item。有的人设计 PPT 的时候会说：“应甲方要求，标题一定要大！”，那这属于元素的“属性”，即 Property。于是我们来抽象实现一下这个布局（注意不是直接能用的代码）：\n// 基本元素如下 Window { // 窗口一个大盒子  Box { // 里面套个小盒子  Title {} // 盒子里面有标题  Description {} // 标题下面有描述  } } 进一步加上居中对齐和间距：\nWindow { Box { anchors.centerIn: parent // 居中对齐大盒子  Title { anchors.horizontalCenter: parent.horizontalCenter // 水平对齐小盒子  } Description { anchors.horizontalCenter: parent.horizontalCenter // 水平对齐小盒子  } } } 可以看到，这里引用了一个 parent 的概念，实际上指代上一层父级元素，套娃套在里面的才是娃，文字和描述的父级元素是小盒子，小盒子的父级元素是大窗口。再补上元素的属性和间距：\nWindow { width: 960 // 窗口宽度  height: 720 // 窗口高度  Box { anchors.centerIn: parent implicitWidth: 360 // 宽度 360 单位（多数情况下理解为像素）  implicitHeight: 128 // 高度 128 单位  Title { anchors.horizontalCenter: parent.horizontalCenter // 水平对齐小盒子  font.pixelSize: 24 // 标题一定要大  } Box { visible: false // 一个看不见的盒子  implicitHeight: 16 // 用于拉开标题和描述的间距  } Description { anchors.horizontalCenter: parent.horizontalCenter // 水平对齐小盒子  font.pixelSize: 16 // 精致的描述用小字  } } } 这些具体元素我们以后会写到如何实现，现在需要用 QtQuick.Controls 提供的一些默认元素替代：\n Box-\u0026gt;Rectangle Title / Description -\u0026gt; Text  import QtQuick 2.12 import QtQuick.Window 2.12 import QtQuick.Controls 2.12 Window { width: 960 height: 720 Rectangle { anchors.centerIn: parent implicitWidth: 360 implicitHeight: 128 color: \u0026#34;#ef7e9ceb\u0026#34; Text { id: title anchors.horizontalCenter: parent.horizontalCenter text: \u0026#34;这是一个大标题\u0026#34; font.pixelSize: 48 } Rectangle { color: \u0026#34;transparent\u0026#34; implicitHeight: 16 } Text { id: description anchors.horizontalCenter: parent.horizontalCenter text: \u0026#34;我吞下玻璃会伤身体\u0026#34; font.pixelSize: 24 } } } 实现之后的效果可能长成了这个样子，对了，但没全对。因为我们这个 Rectangle 不太智能，是个“硬盒”，元素之间会挤在一起，而不是自动拉开保持社交距离。\n awesome_qml \nimport QtQuick 2.12 import QtQuick.Window 2.12 import QtQuick.Controls 2.12 import QtQuick.Layouts 1.12 Window { width: 960 height: 720 Rectangle { anchors.centerIn: parent implicitWidth: 360 implicitHeight: 128 color: \u0026#34;#ef7e9ceb\u0026#34; ColumnLayout { // 一个上下布局的模板  anchors.fill: parent // 沾满小盒子的空间  spacing: 16 // 原先看不见的盒子用默认提供的间距属性实现  Text { id: title Layout.alignment: Qt.AlignHCenter | Qt.AlignVCenter // 换成 Layout 下的居中对齐模式  text: \u0026#34;这是一个大标题\u0026#34; font.pixelSize: 48 } Text { id: description Layout.alignment: Qt.AlignHCenter | Qt.AlignVCenter text: \u0026#34;我吞下玻璃会伤身体\u0026#34; font.pixelSize: 24 } } } } 可以把 ColumnLayout 当作一个更加智能的盒子，它能够把挤在一起的元素上下依次排开。而与之相对的 RowLayout 则是将元素左右排开。\n column_layout \n对比原本想像中的布局要求，可以说是基本实现了(打个九折不过分吧)。\n样式 基本的元素提供了默认的样式和属性，回顾想象图目前还缺少：\n 按钮 背景图  以一个基本的矩形为例，有如下常用属性（QtQuick-Rectangle）\nimport QtQuick.Controls 2.12 Rectangle { width: 16 height: 16 radius: 8 // 圆角半径  color: \u0026#34;white\u0026#34; // 颜色  border.width: 1 // 边框宽度  border.color: \u0026#34;whitesmoke\u0026#34; // 边框颜色 } 带阴影的矩形可以这样实现：\nimport QtQuick.Controls 2.12 import QtGraphicalEffects 1.0 // 包含 DropShadow 效果  Rectangle { // ...  layer.enabled: true layer.effect: DropShadow { horizontalOffset: 1 // 横向偏移  verticalOffset: 1 // 纵向偏移  radius: 16 // 阴影半径  samples: 17 // 采样率（越高效果越好，性能消耗也增大）  color: \u0026#34;#10000000\u0026#34; // ARGB（透明度，红，绿，蓝）  } } 为矩形添加渐变色：\nRectangle { // ...  rotation: 0 // 渐变角度  gradient: Gradient { GradientStop { position: 0 color: \u0026#34;#ef7e9ceb\u0026#34; // 起始颜色  } // 可以添加多段  GradientStop { position: 1 color: \u0026#34;#c5000000\u0026#34; // 结束颜色  } } } qml.qrc 文件中管理所有的静态资源，可以右键在编辑器中打开，然后添加图片资源：\n qml.qrc \nRectangle { id: background // ...  Image { anchors.fill: background // 填充背景矩形  source: \u0026#34;qrc:/background.png\u0026#34; // 图片资源  fillMode: Image.PreserveAspectCrop // 填充方式  z:-1 // 由于需要将渐变色作为滤镜效果，所以图片的层级下调  } } 如果去掉 z 轴高度设置会发现渐变色在图片下层不可见：\n no_z_index \n事件和交互 虽然 QtQuick.Controls 中提供了 Button 控件，但是我们仍然可以先为自己创立一个简单的按钮。\nRectangle { id: button implicitHeight: 48 implicitWidth: 156 radius: implicitHeight / 2 border.color: \u0026#34;white\u0026#34; // 边框颜色  color: \u0026#34;#ef7e9ceb\u0026#34; // 背景颜色  Text { anchors.verticalCenter: parent.verticalCenter // 居中对齐  anchors.horizontalCenter: parent.horizontalCenter text: \u0026#34;初等記憶體\u0026#34; // 文字内容  color: \u0026#34;white\u0026#34; // 文字颜色  } // 覆盖全按键的鼠标动作区域  MouseArea { anchors.fill: parent Layout.alignment: Qt.AlignHCenter | Qt.AlignVCenter hoverEnabled: true // 允许响应鼠标停留  onEntered: { parent.color = Qt.lighter(button.color, 0.8) // 进入颜色变深  parent.opacity = 1.0 // 不透明  } onExited: { parent.color = Qt.lighter(button.color, 0.9) // 退出颜色变浅  parent.opacity = 0.7 } onClicked: { parent.color = Qt.lighter(button.color, 1.1) // 点击颜色变亮  } } } 这里有一个常见用法可以将需要设置的属性用 property 暴露出来，这样便于统一设置和更改，以及将来要写自己组件时便于外部设置，使用 state 可以提供若干个对象默认状态进行切换，这部分后面会见到。\nRectangle { // ...  property string buttonColor: \u0026#34;#ef7e9ceb\u0026#34; property string buttonText color: buttonColor // 引用属性值 } ","date":"2021-07-20T10:58:40+08:00","image":"https://axionl.me/p/ohmyqt-%E7%B3%BB%E5%88%97-01_helloworld/preview2_hu56ef77228714123a900f9c56e7cffbb3_121405_120x120_fill_box_smart1_3.png","permalink":"https://axionl.me/p/ohmyqt-%E7%B3%BB%E5%88%97-01_helloworld/","title":"[OhMyQt 系列] 01_HelloWorld"},{"content":" 最近还在填坑 \u0026ldquo;The Wayland Protocol\u0026rdquo; 这本书的翻译，由于内容比较独立，所以用 mdbook 单独构建了一份文档页。目前最大的个感受是其设计模式上和 grpc 有异曲同工之妙，等全篇完工后在博客简要介绍一下，希望不咕。\n 文档地址：wayland.axionl.me\n","date":"2021-04-24T17:32:39+08:00","image":"https://axionl.me/p/the-wayland-protocol/wayland_hu0adbd50c5ecec4ec41a5eaa3a1a2a25b_328685_120x120_fill_box_smart1_3.png","permalink":"https://axionl.me/p/the-wayland-protocol/","title":"The Wayland Protocol"},{"content":"序言 Linux 下的用户环境变量配置常显得十分琐碎，如 .xprofile、.pam_environment 亦或是各种 shell 配置文件。\n .xprofile 受限于 x11 服务，在 wayland 或未启动图形界面等情况下不会被读取。 .pam_environment 由于提权漏洞频出（如：CVE-2010-4708、CVE-2011-3148），已经被上游遗弃，一些发行版为了兼容老的用户配置，在 /etc/pam.d/system-login 中临时加入 session required pam_env.so user_readenv=1  以恢复读取该文件中环境变量的行为，并非长久之计。  参考了依云的 Linux 的环境变量怎么设 一文，遂选用 systemd 的 environment.d 作为用户环境变量配置方案。\n介绍 配置文件目录如下：\n ~/.config/environment.d/*.conf [✓] /run/environment.d/*.conf /etc/environment.d/*.conf /usr/lib/environment.d/*.conf /etc/environment  其写法如下：\n 环境变量=值 环境变量=${值:-如果为空的默认值} 环境变量=${值:+添加值} 可以读取 $HOME, $PATH 等原有的环境变量，如：PATH=~/.local/bin:$PATH   apps.conf \n由于我是 fish + tmux 用户，需要自己导出一下生成的环境变量文件到命令行。\n~/.config/fish/conf.d/env_init.fish\nif not contains $USER $PATH export (/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator) end  show environments \n关于 KDE/Plasma 的补充  Plasma and the systemd startup\n 在 Plasma 5.21 和 Systemd 246 以及后续更新版本中，可以使用 systemd 来启动和管理 KDE 服务。\n其中一个好处在于：其环境变量可直接继承自 environment.d 而无需再手动设置 systemd-environment-d-generator 生成的环境变量。\n启用后重启生效。\n$ kwriteconfig5 --file startkderc --group General --key systemdBoot true 使用 Systemd 进行管理后可利用其 CGroups 限制资源分配和使用等诸多特性（或许可以给你的应用加上 cgproxy?），进一步细化和统一用户配置方案，再次感谢开发者为此做出的努力。\n$ systemctl --user set-property app-telegramdesktop-b9317feb02e54b4c93dd1c97a06711a4.scope MemoryMax=1500M MemoryLimit=1G $ systemctl --user status app-telegramdesktop-b9317feb02e54b4c93dd1c97a06711a4.scope ● app-telegramdesktop-b9317feb02e54b4c93dd1c97a06711a4.scope - Telegram Desktop Loaded: loaded (/usr/share/applications/telegramdesktop.desktop; transient) Transient: yes Drop-In: /run/user/1000/systemd/transient/app-telegramdesktop-b9317feb02e54b4c93dd1c97a06711a4.scope.d └─50-MemoryLimit.conf, 50-MemoryMax.conf Active: active (running) since Tue 2021-02-23 21:02:37 CST; 5min ago Tasks: 44 (limit: 18425) Memory: 351.0M (max: 1.4G limit: 1.0G) CPU: 20.056s CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/app-telegramdesktop-b9317feb02e54b4c93dd1c97a06711a4.scope └─15363 /usr/bin/telegram-desktop -- ","date":"2021-02-23T20:35:26+08:00","image":"https://axionl.me/p/linux-%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/wallhaven-vmyg6l_huf5720345d1f95701fdc400deb49d5893_1019259_120x120_fill_q75_box_smart1.jpg","permalink":"https://axionl.me/p/linux-%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/","title":"Linux 用户环境变量设置"},{"content":"前言  项目地址：twpayne/chezmoi\n 早前看了 Farseerfc 老师这篇译文，开始用 Stow 打理自己家目录中的配置文件，其实现非常简单直接：在一个特定的目录保留原始配置文件，并在其原本对应的位置创建软链接。\n 【譯】使用 GNU stow 管理你的點文件 \n 相比之下，其有如下缺点促使我切换到 Chezmoi:\n 需要手动创建目录结构，而不是根据现有配置文件来生成 需要手动建立版本管理，本身不提供备份和恢复等功能 2.3.0 版本加入了隐藏文件显式命名的方案，但还是需要手动添加 dot- 前缀 隐私数据加密  安装  https://www.chezmoi.io/docs/install/\n 多数包管理器可以搜索到此包进行安装，包括 Linux、BSD、macOS、Windows 在内的多种平台。\n$ curl -sfL https://git.io/chezmoi | sh 快速上手 初始化 $ chezmoi init --apply 这会在 ~/.local/share/chezmoi 中创建一个目录权限为 700 的 git 仓库，用于保存配置文件。\n $ chezmoi source-path 可以列出其路径 $ chezmoi cd 可以直接进入到该目录 --apply 参数意为仓库创建后自动添加配置文件，默认为不创建 $ chezmoi init \u0026lt;git_repo\u0026gt; 可在新设备上初始化上传的配置仓库  若包管理器未安装自动补全，则可由下例所示，添加到 \u0026lt;bash/zsh/fish/powershell\u0026gt; 配置当中。\n$ chezmoi completion fish \u0026gt; ~/.config/fish/completions/chezmoi.fish  -o \u0026lt;filename\u0026gt; 输出到文件，默认为标准输出  添加文件或目录 $ chezmoi add .nanorc # 添加文件 $ chezmoi add -x .config/fish/functions/ # 添加文件夹 $ chezmoi add -xa .config/fish/functions # 递归添加文件夹和子目录下的全部内容 $ chezmoi add -T .xprofile # 添加临时内容 $ chezmoi add .tmux.conf --follow # 添加软链接对应的原始内容，而不是软链接符号 $ chezmoi managed # 列出所管理的内容路径 编辑和应用 $ chezmoi edit ~/.bashrc --apply  其默认不带 --apply 参数，所以编辑完成后也不会直接作用于源文件，--dry-run 参数可以空运行而不改变目标文件 $EDITOR 环境变量决定所使用的编辑器。 $ chezmoi diff 以查看改动 $ chezmoi -v apply 应用改动  同步与合并 $ chezmoi source pull -- --rebase \u0026amp;\u0026amp; chezmoi diff $ chezmoi apply --verbose 其同步操作与 git 本身无异，通过 -- 可以传递所需参数。\n$ chezmoi source add .nanorc $ chezmoi source commit -- -m \u0026#34;Initial commit\u0026#34; 支持自动提交，但考虑到用户可能意外添加敏感数据的情况下不建议开启，配置文件的介绍将在稍后提到。\n# ~/.config/chezmoi/chezmoi.toml [sourceVCS] autoCommit = true autoPush = false 也可以一次打包成压缩包放 U 盘上硬件备份\n$ chezmoi archive --output=dotfiles.tar 小结  doctor \n其还提供了一个名为 secret 的参数，是各种加密存储管理软件命令行客户端的包装 (cli wrapper)，chezmoi doctor 可以检测机器中对应可执行文件的安装状态，此部分内容和应用会在后面的数据模板中提及。\n至此，快速上手基本功能已介绍完毕，初次使用发现它像是一个功能丰富的 wrapper，提供了诸多自动化的帮助，包括编辑、冲突合并、同步和导出备份等。可以注意到一个与其他以软链接形式的 dotfiles manager 不同，由于在设计之初就考虑到了多设备、跨平台的兼容方案，chezmoi 并没有选择以软链接的形式来替换源文档所在路径，一方面提供了改动与应用之间的缓冲，另一方面规避了多平台的兼容性问题。\n数据模板 以 Hugo 作为博客或者使用过 go template 的朋友一定不会对此感到陌生，得益于 golang 的实现，chezmoi 不仅做到了单文件、跨平台使用，还继承了其强大的数据模板功能，可以对于不同的设备实现不同的数据配置，比如配置不同的 ssh key，这也是与诸多的 dotfiles manager 的不同之处。\n创建模板 以 .gitconfig 为例，原文如下：\n[user] name = axionl email = axionl@example.com 为了在不同的设备电脑上使用不同的 git 账户这一需求，要将其中的用户信息数据与配置文件进行绑定，而原文件将作为 .tmpl 为后缀的模板文件保存。\n# ~/.local/share/chezmoi/dot_gitconfig.tmpl [user] name = \u0026#34;{{ .name }}\u0026#34; email = \u0026#34;{{ .email }}\u0026#34; 模板文件如上，{{ }} 是 go template 的数据变量标记符，. 代表了当前变量，即在非循环体内，. 就代表了传入的那个变量。一般的变量定义可由赋值表达式定义 {{ $variable := Balabala }}，不过这里 chezmoi 会根据配置文件自动生成和对应。\n$ chezmoi add --autotemplate ~/.gitconfig chezmoi 提供了自动生成模板的功能，但是聪明的生成器未必懂你心意，正如我的 hostname 恰好等于 username 而在其他机器上未必如此。\n dot_gitconfig.tmpl \n此时重新 $ chezmoi edit ~/.gitconfig 对应编辑的就是模板文件（就不要图快加上 --apply 了，以免产生不必要的手滑）。$ chezmoi data 的内容便是其妄加猜测的根源，对应变量也可以手动添加使用，如下，根据系统类型来判断模板中的内容是否作用于该机器，- 符号用于移除前或者后的空格，更多语法可去 go template 参阅。\n# ~/.local/share/chezmoi/dot_gitconfig.tmpl {{ifeq.chezmoi.os\u0026#34;linux\u0026#34;-}}[core] editor = nvim {{else}}[core] editor = {{.github.editor}}{{end-}}对于大量需要编辑内容的配置文件，也可根据不同机器直接做多份同名文件，并对应进行切换。\n# symlink_dot_bashrc.tmpl .bashrc_{{.chezmoi.os}}这将会创建一个 ~/.bashrc 的软链接到对应的配置文件, 若不希望以软链接形式，{{ include \u0026quot;.bashrc_linux\u0026quot; }} 可以直接替换为文件。.chezmoiignore 用于确保对应的系统安装对应的文件，意为如果不匹配，则忽略对应的配置文件，此外还有 .chezmoiremove 等，详见 reference。\n# .chezmoiignore {{ifne.chezmoi.os\u0026#34;darwin\u0026#34;}}.bashrc_darwin {{end}}{{ifne.chezmoi.os\u0026#34;linux\u0026#34;}}.bashrc_linux {{end}}在配置文件内写入对应的数据，TOML 语法可去 toml.io 快速上手，大有（声）裨（安）益（利）。除此之外，chezmoi 还支持由 github.com/spf13/viper 的 json, hcl, yaml 等格式，均以 chezmoi 加不同扩展名命名，将会使用第一个被找到的配置文件。\n 配置文件模板\n # ~/.config/chezmoi/chezmoi.toml [data] [data.github] editor = \u0026#34;nano\u0026#34; 如下命令可临时调试时，脱离模板文件查看变量值是否正确。\n$ chezmoi execute-template \u0026#39;{{- .github.editor -}}\u0026#39; nano⏎ 编辑配置 相比于自动创建模板的南辕北辙，通过智能人工从模板中自动生成 TOML 配置则显得较为靠谱。\n# ~/test.tmpl {{-$email:=promptString\u0026#34;email\u0026#34;-}}[data] email = \u0026#34;{{$email}}\u0026#34; 通过 promptString 这个函数解析等下从命令行中传入的参数，并传入到配置文件中。\n$ chezmoi execute-template --init --promptString email=axionl@example.com \u0026lt; ~/test.tmpl [data] email = \u0026#34;axionl@example.com\u0026#34; 管理私有数据 chezmoi 通过检测原有目录和文件权限来判断是否属于私有，通常以 private_ 为前缀， 0644 为权限，~/.local/share/chezmoi 则为 700 权限，并且运行时会检查该文件夹权限是否正确。\n以下面三种方式为例，介绍 chezmoi 的加密部分：\n GPG Gnome Keyring KeepassXC  其余还有 Lastpass, OnePassword 等用法。\nGPG 支持对称和非对称密钥加密两种方式。\n非对称加密方式中，可用如下命令查看接受方名称，所用 shell 支持的话也可以 $ gpg --recipient \u0026lt;Tab\u0026gt; 进行补全。\n$ gpg --list-public-keys pub ed25519 2019-07-04 [SC] [expires: 2024-07-02] 1FDBDCE2D26BD8F100EE2E73B1B9AAD8BE7E7326 uid [ultimate] ArielAxionL \u0026lt;i@axionl.me\u0026gt; 以接受方竟是我自己为例，在配置文件 chezmoi.toml 中填入：\n# ~/.config/chezmoi/chezmoi.toml [gpg] recipient = \u0026#34;ArielAxionL\u0026#34; 将文件加密并添加，chezmoi 默认使用了 gpg --armor 参数使得加密文件可读，可以通过配置中，的 command 字段来定义 gpg 的其他参数。\n$ chezmoi add --encrypt test.toml  加密内容   解密内容 \n对称加密：\n# ~/.config/chezmoi/chezmoi.toml [gpg] symmetric = true Gnome Keyring  github.com/zalando/go-keyring\n Linux 中环境下，keyring 的实现目前还只支持 gnome-keyring，希望以后也能提供 kwallet 版本的接口。macOS 则支持 Keychain 存储帐号密码。\n$ chezmoi secret keyring set --service=github --user=\u0026lt;github-user\u0026gt; Password: \u0026lt;github-token\u0026gt; 将 set 替换成 get 从命令行拿到所存密令，或者使用 Seahorse 客户端查看。\n Seahorse 是一个管理 gnome-keyring 的软件 \n# ~/.local/share/chezmoi/dot_gitconfig.tmpl [github] user = \u0026#34;{{.github.user}}\u0026#34; token = \u0026#34;{{keyring\u0026#34;github\u0026#34;.github.user}}\u0026#34; chezmoi.toml 配置文件中写明用户名，模板中便可自动取用 gnome-keyring 先前所存 token，keyring 一般会在用户登陆时自动解锁 GNOME/Keyring。\nKeepassXC 配置文件\n# ~/.config/chezmoi/chezmoi.toml [keepassxc] args = [\u0026#34;--key-file\u0026#34;, \u0026#34;/path/to/your/key\u0026#34;] database = \u0026#34;/path/to/your/kdbx\u0026#34; 默认字段有 Notes, Password, URL, Username, 测试获得密码字段，Entry 可以填入保存密码的 Title，keepassxc-cli 会返回一个匹配的结果。\n$ chezmoi execute-template \u0026#39;{{ (keepassxc \u0026#34;\u0026lt;YourEntry\u0026gt;\u0026#34;).Password }}\u0026#39; KeepassXC 支持自定义字段，比如你的密钥： 在模板中用 keepassxcAttribute 获取：\n$ chezmoi execute-template \u0026#39;{{ keepassxcAttribute \u0026#34;VPS Keyring\u0026#34; \u0026#34;public-key\u0026#34; }}\u0026#39; 结束 得益于数据模板的引入，chezmoi 作为一款 dotfiles manager，其配置管理功能相较之下更加强大，也有更多新的功能和应用场景可以发掘。\n","date":"2021-01-29T10:04:51+08:00","image":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-%E7%94%A8-chezmoi-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/wallhaven-j85o5q_hud6f9c8919d070f75481ccdcf5e8a2ef3_499154_120x120_fill_q75_box_smart1.jpg","permalink":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-%E7%94%A8-chezmoi-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"[归档] 用 Chezmoi 管理配置文件"},{"content":" 自用配置项，持续更新中\u0026hellip;\u0026hellip;\n 选项  允许加载用户样式文件（userChrome.css）  toolkit.legacyUserProfileCustomizations.stylesheets = true  调整浏览器标签宽度  browser.tabs.tabClipWidth = 83  硬件加速  media.ffmpeg.vaapi.enabled = true media.ffvpx.enabled = false 配合系统环境变量使用 MOZ_X11_EGL=1 或 MOZ_ENABLE_WAYLAND=1，MOZ_WEBRENDER=1\n Devtools  devtools.editor.tabsize = 4 devtools.debugger.remote-enabled = true DevTools 中还有 Enable browser chrome and add-on debugging toolboxes 可以打开，调试扩展常用选项\n 易用模式  accessibility.typeaheadfind.enablesound = false 默认开了这个选项，导致 Ctrl+F 搜索不到结果的时候笔记本的蜂鸣器会吼得很大声\n主题  MaterialFox\n 扩展   Tree Style Tab\n TST Preview \n  userChrome.css 外部配置 treestyletab.css\n  插件内嵌样式配置 custom.css\n  调试插件样式的方法\n  Debug Add-ons   Debug Runtime   Debug TST Page   Debug TST       TST Bookmarks Subpanel\n  SwitchyOmega\n  Auto Tab Discard\n  Keepassxc Browser\n   Plasma Integration    Saladict\n  Tampermonkey\n 一个用于 ArchWiki 目录 侧边显示的脚本   ArchWiki TOC \n  User-Agent Switcher and Manager\n  ","date":"2021-01-27T16:24:43+08:00","image":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-hello-my-firefox/wallhaven-eo5jko_hu1370c1b8c65664b9aa6fe97e7a98b26c_28390_120x120_fill_box_smart1_3.png","permalink":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-hello-my-firefox/","title":"[归档] Hello, My Firefox"},{"content":"前言 2019 年 1 月的时候知道了这个发行版，当时 @NixOS_zh 群刚建立（后来这群凉了），就开虚拟机玩了一下，时隔多年发现又有不少人对其颇感兴趣，便决定重新写一下安装相关的教程。\n本文以 Arch Linux 作为宿主机，大体步骤与 Arch Wiki 相近\nQEMU/KVM 虚拟机配置  ArchLinux Wiki: KVM | QEMU | Libvirt\n 0. 检测硬件是否支持 KVM 一般情况下需要进入到 BIOS 对应页面打开虚拟化支持，常见对应设置项如下：\n AMD: SVM Support Intel: Intel Virtual Technology  开启虚拟化后在宿主机上用命令行检测（比如我的是 AMD 的处理器）：\n$ LC_ALL=C lscpu | grep Virtualization Virtualization: AMD-V 内核支持检测，如果使用的是 ArchLinux 提供的官方内核，即 core/linux 则已经包含了对应的 kvm 模块（kvm、kvm_amd或kvm_intel）:\n$ zgrep CONFIG_KVM /proc/config.gz CONFIG_KVM_GUEST=y CONFIG_KVM_MMIO=y CONFIG_KVM_ASYNC_PF=y CONFIG_KVM_VFIO=y CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y CONFIG_KVM_COMPAT=y CONFIG_KVM_XFER_TO_GUEST_WORK=y CONFIG_KVM=m CONFIG_KVM_INTEL=m CONFIG_KVM_AMD=m # 可以看到有该模块 CONFIG_KVM_AMD_SEV=y CONFIG_KVM_MMU_AUDIT=y 查看这些内核模块是否已自动加载：\n$ lsmod |grep kvm kvm_amd 114688 8 ccp 118784 1 kvm_amd kvm 933888 1 kvm_amd irqbypass 16384 1 kvm 如果没有自动加载则手动：\n$ sudo modprobe kvm $ sudo modprobe kvm_amd # 对应你的 CPU 类型 1. 准虚拟化（使用 VIRTIO） 检测 VIRTIO 模块是否可用：\n$ zgrep VIRTIO /proc/config.gz CONFIG_BLK_MQ_VIRTIO=y CONFIG_VIRTIO_VSOCKETS=m CONFIG_VIRTIO_VSOCKETS_COMMON=m CONFIG_NET_9P_VIRTIO=m CONFIG_VIRTIO_BLK=m CONFIG_SCSI_VIRTIO=m CONFIG_VIRTIO_NET=m CONFIG_VIRTIO_CONSOLE=m CONFIG_HW_RANDOM_VIRTIO=m CONFIG_DRM_VIRTIO_GPU=m CONFIG_VIRTIO=y CONFIG_VIRTIO_MENU=y CONFIG_VIRTIO_PCI=m CONFIG_VIRTIO_PCI_LEGACY=y CONFIG_VIRTIO_VDPA=m CONFIG_VIRTIO_PMEM=m CONFIG_VIRTIO_BALLOON=m CONFIG_VIRTIO_MEM=m CONFIG_VIRTIO_INPUT=m CONFIG_VIRTIO_MMIO=m CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES=y CONFIG_VIRTIO_DMA_SHARED_BUFFER=m CONFIG_RPMSG_VIRTIO=m CONFIG_VIRTIO_FS=m CONFIG_CRYPTO_DEV_VIRTIO=m 准虚拟化设备列表（主要确保以下几个模块有对应开启，若未开启则手动用 modprobe 命令开启）：\n 网络设备 (virtio-net) 硬盘设备 (virtio-blk) 控制器设备 (virtio-scsi)  2. 安装 QEMU $ sudo pacman -S qemu  Arch Wiki: PCI 直通\n 如果需要启用 PCI 直通功能则需要在内核参数中添加 intel_iommu=on 或者 amd_iommu=on，同时可以在其后添加 iommu=pt，以防前者失效，以下命令检测是否开启成功，由于本人所用 AMD Ryzen 5 4600U 支持方面还有些问题，故此不做展示。\n$ sudo dmesg | grep -i -e DMAR -e IOMMU 3. 安装 libvirt $ sudo pacman -S libvirt virt-manager dnsmasq edk2-ovmf 为了避免每次都需要询问 root 密码，建议将自己的用户添加到 libvirt 组：\n$ sudo usermod -aG libvirt \u0026lt;YourUserName\u0026gt; 编辑服务端配置文件 /etc/libvirt/libvirtd.conf，取消如下几行的注释：\nunix_sock_group = \u0026quot;libvirt\u0026quot; unix_sock_ro_perms = \u0026quot;0777\u0026quot; # set to 0770 to deny on-group libvirt users unix_sock_rw_perms = \u0026quot;0770\u0026quot; auth_unix_ro = \u0026quot;none\u0026quot; auth_unix_rw = \u0026quot;none\u0026quot; 同时添加 ipv4 的内核转发参数：\n$ sudo echo \u0026#39;net.ipv4.ip_forward = 1\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.d/00-network.conf 设置开机启动和运行服务。\n$ sudo systemctl enable --now libvirtd.service 4. 配置 virt-manager  添加连接 \n建议重启以应用之前的设置，此时在 Virtual Machine Manager 的界面应该可以看到一些已经连接上的服务端，如果没有则在菜单栏自行添加，推荐初次连接系统级服务来创建虚拟机。\n 添加虚拟机 \n NixOS 镜像下载\n 将下载到的镜像文件所在目录创建为文件系统池，随后在其中选择镜像文件进行加载。\n 添加镜像池   选择镜像 \n设置合适的系统资源和网络配置等（初次使用推荐用 NAT 模式较为简单，Bridge 模式之后会提到如何配置）。\n 虚拟机能用的内存和CPU核心数量设置   存储空间设置 \n如果你的宿主机支持的话，推荐使用 UEFI 模式启动（由 extra/edk2-ovmf 这个提供，中途安装的话要重启 libvirtd 服务以生效）。\n EFI Firmware \n调整镜像到启动优先级最高，最后启动工具栏上的 Begin Install 就可以安装了。  更改启动优先级 \nNixOS 系统安装  NixOS 使用手册\n 0. 进入引导界面  ISO Grub   NixOS 镜像启动 \n由于我下载的是最小化镜像，所以并没有图形界面，如果下载的是带 Gnome 或者 KDE 的镜像的话应该可以看到界面了，稍后我也会以最小化镜像的方式开始安装图形界面。\n1. 磁盘分区 查看当前块设备状态，可以看到我们之前分配的盘 vda 还未被挂载\n lsblk \n建议使用 GPT 分区表，按照可以按照图中对 boot、swap(可选)和 root 分区进行创建，注意下方 Type 选择对应的分区类型，Write 写入后退出。\n$ sudo cfdisk /dev/vda  cfdisk \n格式化分区，可以看到格式化后效果如下：\n$ sudo mkfs.fat -F32 /dev/vda1 $ sudo mkswap /dev/vda2 $ sudo swapon $ sudo mkfs.xfs -L root /dev/vda3  mkfs check \n2. 分区挂载 $ sudo mount /dev/vda3 /mnt $ sudo mkdir -p /mnt/boot $ sudo mount /dev/vda1 /mnt/boot 挂载后可以检查是否挂载成功，不要重复挂载。\n 挂载 \n3. 系统配置 由命令生成默认的配置文件：\n$ sudo nixos-generate-config --root /mnt $ sudo nano /mnt/etc/nixos/configuration.nix 可以看到已经有了 systemd-boot 作为 bootloader 引导操作系统。其他一些基本配置，按照自己的需求取消注释并修改内容即可，注意创建用户 users.users.\u0026lt;YourUserName\u0026gt; 及其对应的用户组，完成后 Ctrl + O 保存。\n config \n如果网络情况欠佳的话可以设置 http_proxy 或者更换更新频道到国内镜像站：\n TUNA Nix Help\n $ sudo nix-channel --add https://mirrors.tuna.tsinghua.edu.cn/nix-channels/nixos-20.09 nixos 使用 sudo nixos-install 进行安装并设置 root 密码，完成之后取消挂载并重启（记得更改启动项顺序到虚拟硬盘）。\n$ sudo nixos-install ... setting root password... Enter new UNIX password: *** Retype new UNIX password: *** $ sudo umount -r /mnt $ reboot  调整启动顺序 \nNixOS 系统配置和使用 0. 检查引导状态 重启登陆后可以查看引导状态：\n$ sudo bootctl status  systemd-boot 状态 \n1. 配置桌面环境 /etc/nixos/configuration.conf 配置文件参考如下\n# Edit this configuration file to define what should be installed on # your system. Help is available in the configuration.nix(5) man page # and in the NixOS manual (accessible by running ‘nixos-help’). { config, pkgs, ... }: { imports = [ # Include the results of the hardware scan. ./hardware-configuration.nix ]; # Use the systemd-boot EFI boot loader. boot.loader.systemd-boot.enable = true; boot.loader.efi.canTouchEfiVariables = true; networking.hostName = \u0026#34;axionl\u0026#34;; # 设置 hostname. # networking.wireless.enable = true; # Enables wireless support via wpa_supplicant. # Set your time zone. time.timeZone = \u0026#34;Asia/Shanghai\u0026#34;; # 设置时区 # The global useDHCP flag is deprecated, therefore explicitly set to false here. # Per-interface useDHCP will be mandatory in the future, so this generated config # replicates the default behavior. networking.useDHCP = false; networking.interfaces.enp1s0.useDHCP = false; networking.networkmanager.enable = true; # 启用 NetworkManager 替代默认的 DHCP # Configure network proxy if necessary networking.proxy.default = \u0026#34;http://192.168.122.1:8888\u0026#34;; # 设置一个外部代理（可选） # networking.proxy.noProxy = \u0026#34;127.0.0.1,localhost,internal.domain\u0026#34;; # Select internationalisation properties. i18n.defaultLocale = \u0026#34;en_US.UTF-8\u0026#34;; # 默认语言环境 # console = { # font = \u0026#34;Lat2-Terminus16\u0026#34;; # keyMap = \u0026#34;us\u0026#34;; # }; # Configure keymap in X11 services.xserver.layout = \u0026#34;us\u0026#34;; # 设置键盘布局 # services.xserver.xkbOptions = \u0026#34;eurosign:e\u0026#34;; # Enable CUPS to print documents. services.printing.enable = false; # 启用打印服务（不需要可禁止） # Enable sound. sound.enable = true; # 允许声音 hardware.pulseaudio.enable = true; # Enable touchpad support (enabled default in most desktopManager). services.xserver.libinput.enable = true; # 允许触摸板 # Define a user account. Don\u0026#39;t forget to set a password with ‘passwd’. # 创建用户并添加到用户组 users.users.axionl = { isNormalUser = true; extraGroups = [ \u0026#34;wheel\u0026#34; \u0026#34;networkmanager\u0026#34; ]; # Enable ‘sudo’ for the user. shell = pkgs.fish; # 指定终端（默认为 bash） }; # List packages installed in system profile. To search, run: # $ nix search wget # 在系统层面安装软件包 environment.systemPackages = with pkgs; [ htop neofetch fish spice-vdagent virglrenderer ]; # Some programs need SUID wrappers, can be configured further or are # started in user sessions. # programs.mtr.enable = true; # programs.gnupg.agent = { # enable = true; # enableSSHSupport = true; # }; # List services that you want to enable: # Enable the OpenSSH daemon. # services.openssh.enable = true; # Open ports in the firewall. # networking.firewall.allowedTCPPorts = [ ... ]; # networking.firewall.allowedUDPPorts = [ ... ]; # Or disable the firewall altogether. # networking.firewall.enable = false; # This value determines the NixOS release from which the default # settings for stateful data, like file locations and database versions # on your system were taken. It‘s perfectly fine and recommended to leave # this value at the release version of the first install of this system. # Before changing this value read the documentation for this option # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html). system.stateVersion = \u0026#34;20.09\u0026#34;; # Did you read the comment? # X Windows Server # 启动 X 显示服务 services.xserver.enable = true; # services.qemuGuest.enable = true; # services.spice-vdagentd.enable = true; # 允许 SDDM 作为窗口管理器 services.xserver.displayManager.sddm.enable = true; # 安装 Plasma KDE 作为桌面环境 services.xserver.desktopManager.plasma5.enable = true; # Packages # 允许第三方闭源软件包 nixpkgs.config.allowUnfree = true; } 修改配置文件之后需要使用命令重建并推荐重启生效：\n$ sudo nixos-rebuild switch --upgrade 日常使用的时候理论上可以多套配置（profile）兼容和切换，当配置过多的时候可用 nix-collect-garbage -d 来完成，详见文档。\n在用户层面安装软件包使用 nix 包管理器进行搜索和安装：\n$ nix search \u0026lt;软件包名称\u0026gt; # 搜索 $ nix-env -i \u0026lt;软件包名称\u0026gt; # 安装 $ nix-env -qa # 列出可安装的包 $ nix-env -e \u0026lt;软件包名称\u0026gt; # 卸载软件包 $ nix-env --rollback # 软件包回滚  更多用法可见官方文档\n 2. 截图  预览 \n","date":"2021-01-07T22:57:51+08:00","image":"https://axionl.me/p/%E5%9C%A8-qemu/kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85-nixos-%E5%8F%91%E8%A1%8C%E7%89%88/preview_hud7b98d8f2b15df53359a72384550edee_2355505_120x120_fill_box_smart1_3.png","permalink":"https://axionl.me/p/%E5%9C%A8-qemu/kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85-nixos-%E5%8F%91%E8%A1%8C%E7%89%88/","title":"在 QEMU/KVM 虚拟机上安装 NixOS 发行版"},{"content":"前言  官方网站\n gRPC Protocol Buffers   通俗易懂的说明  introduction \n以宽泛的概念来说就是找到一种公共的中间体，以达到两者“交流”的目的。\n有点复杂的介绍 RPC(Remote Procedure Call) 远程过程调用，可简单理解为远程的程间通讯。gRPC 是 Google 所实现的一个开源框架，Protocol Buffers 是用于通信的数据载体格式，有着高压缩率（序列化后）、跨平台、多语言等优点。\n虽然定义上是远程通讯，但扩展到仅本地使用就成了一种形式上的程间通讯。gRPC 通过网络栈实现这一过程，而 Apache Thrift 则包含了网络、命名管道、内存共享等多种数据交换形式，留作以后介绍和对比。通过序列化工具 (Protocol Buffers) 在节省带宽和减少传输时间的基础上，又能够轻易还原回原本的结构数据，便于多语言开发，部分软件也以此作为其 API 暴露方式，如 v2ray 等。\n 流程示意图 \n一个简单的例子 以一个消息内容为空的协议为例子，仅用于确认发送和响应。对于 golang\t或者 java 等语言来说 proto3 支持以 option 的方式产生适合其代码引入的包封装 (详见)。\n 公共协议  syntax = \u0026#34;proto3\u0026#34;;option go_package = \u0026#34;example.com/user/grpcGoExample\u0026#34;message HelloMessage {} // 公共消息体，未包含任何字段 /* 通讯服务声明，类似于我们常说的接口 */service Greeter { rpc SayHello(HelloMessage) returns (HelloMessage);} golang 客户端  import ( ... pb \u0026#34;example.com/user/grpcGoExample\u0026#34; ) // 具体方法实现 func (g *Greeter) sayHello() { // 生成上下文 \tctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() // 获取服务端响应，在执行这条指令后可以看到进入了服务端对应的方法 \tresponse, err := g.client.SayHello(ctx, \u0026amp;pb.HelloMessage{}) if err != nil { log.Fatalf(\u0026#34;Failed to get the response: %v\u0026#34;, err) } if response != nil { fmt.Print(\u0026#34;Hello Server\u0026#34;) } } func main() { // 本地临时创建一个不安全的链接(socks5)  const Address = \u0026#34;localhost:50051\u0026#34; conn, err := grpc.Dial(Address, grpc.WithInsecure(), grpc.WithBlock()) if err != nil { log.Fatalf(\u0026#34;Failed to connect: %v\u0026#34;, err) } defer conn.Close() var client = pb.NewGreeterClient(conn) greeter := Greeter{client: client} greeter.sayHello() // 调用方法 }  服务端  import ( ... pb \u0026#34;example.com/user/grpcGoExample\u0026#34; ) type server struct { pb.UnimplementedGreeterServer } // 方法具体实现 func (s *server) SayHello(ctx context.Context, message *pb.HelloMessage) (*pb.HelloMessage, error) { // 请求陷入该方法后输出字符串，表示服务器已经收到该指令 \tlog.Println(\u0026#34;Hello Client!\u0026#34;) // 返回响应 \treturn \u0026amp;pb.HelloMessage{}, nil } func main() { // 监听一个本地端口 \tlis, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;0.0.0.0:50051\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v\u0026#34;, err) } else { log.Printf(\u0026#34;Listen on: %v...\u0026#34;, Address) } // 创建服务端 \ts := grpc.NewServer() pb.RegisterGreeterServer(s, \u0026amp;server{}) if err := s.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v\u0026#34;, err) } } 可以看到，在基本不需要涉及底层网络开发和同步协定的情况下实现了两个程序之间的通讯，其关键在于服务端重写方法的实现和客户端上下文的获取。在后续的介绍中还会就具体操作过程作详细说明。\nProtocol Buffers 简要 跨语言类型的桥梁  Protocol Buffers\n 作为一种语言中立的协议，其在多种语言中都有对应的变量类型转换，需要特别注意是否在转换过程中出现精度丢失现象，或者并非预期类型的现象，比如 bytes 对应到 C++ 的类型为 string，需要自己适当转换。\n 变量类型对应表 (https://developers.google.com/protocol-buffers/docs/overview#scalar) \n此外支持通过嵌套类型，实现结构体形式的信息的传输和还原。\nmessage PersonalInfo { int32 id = 1;  string name = 2; int32 score = 3; enum Hobby { GAMES = 1; MUSIC = 2; } Hobby hobby = 4;}message PersonalResponse {\tstring msg = 1;}message ClassInfo {\trepeated PersonalInfo c_info = 1;}service SearchInfo {\trpc Add(stream PersonalInfo) returns (PersonalResponse);}更多语法说明可以参考官方文档。\n生成库文件  Protobuf Github Release 下载 (含 protoc)\n 生成所需要用到两个工具，一个是 protoc 其本身，另一个是用于生成对应其他语言文件的插件，后者可能有些发行版已经将对应语言的插件打包到了 grpc 包内一起，视具体情况而定，比如 protoc-gen-go-grpc 正好没有，那就找到上游项目自己安装一个并添加到环境变量中（方便输入）。\n 命令行方式  $ protoc --plugin=protoc-gen-go-grpc --go_out=. --go-grpc_out=. -I=. info.proto 然后生成了 info.pb.go 和 info_grpc.pb.go 两个文件，大体上看前者管定义，后者管实现，属于同一个包。其他语言主要是将二进制插件和输出参数替换成对应语言的。\n cmake 包办  可以参考如下两个 .cmake 文件，自己在 CMakeLists.txt 中设置变量名称。\n## protobuf.cmake # Find Protobuf find_package(Protobuf REQUIRED)# Find Generator Executable find_program(PROTOBUF_PROTOC_EXECUTABLE protoc)# Set Proto Name set(API_PROTO_NAME \u0026#34;\u0026lt;YourProtoName\u0026gt;\u0026#34;)# Set Libraries set(PROTOBUF_LIBPROTOBUF_LIB protobuf::libprotobuf)# Set Proto Path get_filename_component(API_PROTO_PATH \u0026#34;protofile\u0026#34; ABSOLUTE)# File Proto File get_filename_component(API_PROTO \u0026#34;${API_PROTO_PATH}/${API_PROTO_NAME}.proto\u0026#34; ABSOLUTE)# Generated Sources protobuf_generate_cpp(API_PROTO_SRCS API_PROTO_HDRS \u0026#34;${API_PROTO}\u0026#34;)## grpc.cmake # Find gRPC Package find_package(gRPC CONFIG REQUIRED)# Find Generator Executable Plugin find_program(GRPC_CC_PLUGIN_EXECUTABLE grpc_cpp_plugin)# Find PkgConfig find_package(PkgConfig REQUIRED)# Check Modules pkg_check_modules(GRPC REQUIRED grpc++ grpc)# Set Source Files set(API_GRPC_SRCS ${CMAKE_CURRENT_BINARY_DIR}/${API_PROTO_NAME}.grpc.pb.cc)set(API_GRPC_HDRS ${CMAKE_CURRENT_BINARY_DIR}/${API_PROTO_NAME}.grpc.pb.h)# Set Libraries set(GRPC_GRPCPP_LIB gRPC::grpc++)set(GRPC_REFLECTION_LIB gRPC::grpc++_reflection)# Generate gRPC Sources add_custom_command( OUTPUT \u0026#34;${API_GRPC_SRCS}\u0026#34; \u0026#34;${API_GRPC_HDRS}\u0026#34; \u0026#34;${API_PROTO_SRCS}\u0026#34; \u0026#34;${API_PROTO_HDRS}\u0026#34; COMMAND ${PROTOBUF_PROTOC_EXECUTABLE} ARGS --grpc_out=${CMAKE_CURRENT_BINARY_DIR} --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I=\u0026#34;${API_PROTO_PATH}\u0026#34; --plugin=protoc-gen-grpc=\u0026#34;${GRPC_CC_PLUGIN_EXECUTABLE}\u0026#34; \u0026#34;${API_PROTO}\u0026#34; DEPENDS \u0026#34;${API_PROTO}\u0026#34; )一个综合的案例 v2ray config.proto\nsyntax = \u0026#34;proto3\u0026#34;;package v2ray.core;option csharp_namespace = \u0026#34;V2Ray.Core\u0026#34;;option go_package = \u0026#34;v2ray.com/core\u0026#34;;option java_package = \u0026#34;com.v2ray.core\u0026#34;;option java_multiple_files = true;import \u0026#34;common/serial/typed_message.proto\u0026#34;;import \u0026#34;transport/config.proto\u0026#34;;...可以看到首先引入了两个子 proto 文件，其中包含一些自己项目具体定义的消息类型，以 typed_message.proto 为例子，其中只包含了两种类型的两个字段。\nmessage TypedMessage { // The name of the message type, retrieved from protobuf API.  string type = 1; // Serialized proto message.  bytes value = 2;}最终通过层层嵌套构成了一个综合的信息结构体，一并打包发送。\n Banner Artwork\n ","date":"2021-01-03T23:46:51+08:00","image":"https://axionl.me/p/protocol-buffers-%E5%92%8C-grpc%E4%B8%80/banner_hu84ccfb793eb153d5f929caaf8b63424a_357988_120x120_fill_q75_box_smart1.jpg","permalink":"https://axionl.me/p/protocol-buffers-%E5%92%8C-grpc%E4%B8%80/","title":"Protocol Buffers 和 gRPC（一）"},{"content":"介绍  项目地址\n DNS 域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。通常情况下本地的解析请求会发送到离你最近的 DNS 服务器，它可能是你的无线路由器、宿舍楼梯下的服务器或者运营商的地区性服务器等，但由于各种原因导致解析效果不理想，延迟高等问题，这时可以考虑换一个网络质量好的域名解析服务，错峰出行，减少拥堵。\nSmartDNS SmartDNS 集成了多种出栈请求协议，包括常用的 UDP 和较为现代的 DNS-Over-Https 等，能够在给定的规则列表中挑选出一个延迟最低的域名解析服务，并向其发送请求。同时其内部也提供 DNS 缓存，如果缓存能够命中则直接从本地缓存中返回对应 IP 地址，如未能查找到则继续向上级 DNS 服务传播请求。\n配置  默认配置文件\n  推荐项目：dnsmasq-china-list\n 作者肥猫在其项目中提供了几个较为常用的匹配规则列表，对于非 Arch Linux 用户而言可以把项目克隆到本地然后构建对应的配置文件，而 Arch 用户可以从 CN 源 里安装 smartdns-china-list-git 以获取自动更新。\n生成对应的配置文件操作如下，具体参考，可见其生成形式为 nameserver /\u0026lt;域名\u0026gt;/\u0026lt;组名\u0026gt;，后面的组名就是对应我们后来需要的匹配规则而制定的。\n$ cd dnsmasq-china-list $ make smartdns SERVER=china 默认的配置文件中有很多不常用的项目，作为自己的配置文件一般精简到自己需要的功能配置即可。\n# （可选）引入额外的规则列表，用绝对路径conf-file /etc/smartdns/accelerated-domains.china.smartdns.confconf-file /etc/smartdns/apple.china.smartdns.confconf-file /etc/smartdns/google.china.smartdns.conf# 本地监听端口bind [::]:53# 缓存大小cache-size 4096# 重启时读取之前的缓存cache-persist yes# 缓存文件存放位置cache-file /var/cache/smartdns.cache# 传统 UDP 协议（以阿里 DNS 为例）server 223.5.5.5# DNS Over TLS （以 CloudFlare DNS 为例）server-tls 1.0.0.1# DNS Over Https (以烧饼 DNS 为例)server-https https://doh.dns.sb/dns-query -group china -group example 更多 DNS 服务地址：dnscrypt.info\n 如果有多个分组需求，可以自定义规则配置文件，服务配置后面再添加 -group [组名]。\n被 -exclude-default-group 标记为排除在默认组之内的服务需至少在一个组才可能被访问到。\n启动 # smartdns -c smartdns.conf or # systemctl enable --now smartdns.service 默认在后台运行，推荐使用自带的 systemd service 来进行管理，如果 /ect/resolv.conf 没有被更改成监听本地的话可以检查一下文件是否有特殊标志位(lsattr)，手动修改即可(chattr )。\n$ cat /etc/resolv.conf # DNS managed by SmartDNS nameserver 127.0.0.1  Banner Artwork\n ","date":"2021-01-02T09:41:20+08:00","image":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-smartdns-%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%9A%84-dns-%E6%9C%8D%E5%8A%A1/banner_hu9140ed4ac8f869cb7580a737acf169a1_258150_120x120_fill_q75_box_smart1.jpg","permalink":"https://axionl.me/p/%E5%BD%92%E6%A1%A3-smartdns-%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%9A%84-dns-%E6%9C%8D%E5%8A%A1/","title":"[归档] SmartDNS 一个智能分流的 DNS 服务"},{"content":"介绍 一个检测关键词并自动回复表情包的 Telegram 机器人。\n开发 注册一个机器人   访问 Telegram 的官方注册机器人 @BotFather 。\n  使用 /newbot 命令创建一个新的机器人。它会询问你所要创建机器人的名字 (nickname) 和用户名 (username, 以_bot结尾)，注册成功后会将机器人的 TOKEN 返回给你，而这个 TOKEN 用于告知服务器这个机器人就是（大明湖畔那个夏雨荷）对应注册的机器人。\n   botfather \n... Use this token to access the HTTP API: `\u0026lt;1145141919810:TheWholeSentenceIsToken\u0026gt;` Keep your token secure and store it safely, ... 安装 Python 环境  官方网站: https://www.python.org/downloads\n 对于绝大多数 Linux 发行版来说从其自己的包管理器中安装 Python 即可（2021 年了应该都默认 Python3?)\nWindows 则 Python 官方提供了安装器，记得把 Python 加到环境变量 (PATH) 的框给勾选上。\n为了避免开发环境不干净对后续开发和使用系统造成影响，建议创建一个用于该机器人项目的虚拟环境(virtual environment)\n$ python -m venv .venv // 创建了一个名为 .venv 的隐藏文件夹 对于国内使用 PyPi 源速度不是很给力的情况，可以考虑替换镜像源为清华源\n也可以写入默认配置文件 ~/.config/pip/pip.conf（如果没有则创建）\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 可以查看设置是否生效\n$ pip config list global.index-url=\u0026#39;https://pypi.tuna.tsinghua.edu.cn/simple\u0026#39; 创建虚拟环境后，您可以激活它，进入项目所在目录。\n 在 Windows 上，运行:  tutorial-env\\Scripts\\activate.bat  在 Unix 或 MacOS 上，运行:  $ source tutorial-env/bin/activate 对于 csh 和 fish shell 分别对应名为 activate.csh 和 activate.fish 的脚本\n安装软件包依赖  python telegram bot 项目地址\n $ pip install python-telegram-bot --upgrade 也可以将依赖导出到文件，便于开发迁移\n$ pip freeze \u0026gt; requirements.txt Coding Time def main(): # 从环境变量中读取 TOKEN 减少硬编码可能带来的泄漏风险 # 如果只是本地测试的话可以直接把 TOKEN 粘贴到程序中 TOKEN = os.getenv(\u0026#39;TELEGRAM_BOT_TOKEN\u0026#39;) # Updater 是 Dispatcher 的实现，用于机器人数据交互的前端， # 负责更新消息队列并交付给其他调度程序 updater = Updater(token=TOKEN, use_context=True) dispatcher = updater.dispatcher # 开始拉取信息 updater.start_polling() # 响应终止信号 Ctrl+C updater.idle() if __name__ == \u0026#34;__main__\u0026#34;: main() 上述几行代码构成了整个机器人的基本框架，包含了机器人身份认证和开启机器人服务等。我们还需要向该框架内注册具体的方法，以实现所需功能。\ndef start(update: Update, context: CallbackContext) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Send a message when the command /start is issued.\u0026#34;\u0026#34;\u0026#34; reply_text = \u0026#34;你好～\\n\u0026#34; user = update.message.from_user if user.username is not None: reply_text += f\u0026#34;您的用户名是: {user.username}\\n\u0026#34; reply_text += f\u0026#34;ID: {user.id}\u0026#34; update.message.reply_text(reply_text) def help_command(update: Update, context: CallbackContext) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Send a message when the command /help is issued.\u0026#34;\u0026#34;\u0026#34; update.message.reply_text(\u0026#39;这里是帮助命令\u0026#39;) def echo(update: Update, context: CallbackContext) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Echo the user message.\u0026#34;\u0026#34;\u0026#34; update.message.reply_text(update.message.text) def main(): token = os.getenv(\u0026#39;TELEGRAM_BOT_TOKEN\u0026#39;) updater = Updater(token=token, use_context=True) dispatcher = updater.dispatcher dispatcher.add_handler(CommandHandler(\u0026#34;start\u0026#34;, start_command)) dispatcher.add_handler(CommandHandler(\u0026#34;help\u0026#34;, help_command)) dispatcher.add_handler(MessageHandler(Filters.text \u0026amp; ~Filters.command, echo)) updater.start_polling() updater.idle() 从 Update 中可以拿到消息的类型、具体内容、发送者等关键信息，从 CallbackContext 中可以获取机器人本身的一些信息等。在使用 \\ 开头的对应命令后就能进入到对应的方法，也可以对此进行类封装。\n注意到除了 CommandHandler 之外还有其他类型的句柄如常规消息类的 MessageHandler、用于行内输入的的 InlineQueryHandler 等，请详见上游 API 文档。\n回到需求，我们需要的检测关键词部分也是从 Update 中来，用关键词列表简单演示，当消息中包含关键词的时候发送一个表情，或者其他类型的回复详见 Message 类文档。\nfrom telegram import Update, Sticker # 临时创建一个表情量 sticker = Sticker(file_id=\u0026#34;CAACAgUAAxkBAAIMOV_jA7I0IAABMbqNVNGkJWZNiDRT6QACiwIAArL6ew6tFsY1eQy9Lx4E\u0026#34;, file_unique_id=\u0026#34;AgADiwIAArL6ew4\u0026#34;, width=480, height=512, is_animated=False) def echo(update: Update, context: CallbackContext) -\u0026gt; None: keys_list = [\u0026#34;上膛\u0026#34;, \u0026#34;车主\u0026#34;, \u0026#34;特斯拉\u0026#34;] for item in keys_list: if item in update.message.text: msg = update.message msg.reply_sticker(sticker)  echo \n至此初步效果已经达成，剩下要解决的两个疑问就是：\n Sticker 的信息是怎么来的？ 如何回复指定消息  Sticker 信息 可以添加一个专用于获取表情包信息的句柄\ndef get_sticker(update: Update, context: CallbackContext) -\u0026gt; None: logger.info(update.message.sticker) def main(): ... dispatcher.add_handler(MessageHandler(Filters.sticker \u0026amp; ~Filters.command, get_sticker)) ... 为了便于理解这里在服务端后台直接输出表情包信息作为日志，对于一些要动态添加表情包和对应关键字的需求来说，一个轻便的可持久化数据才是更好的选择。创建 Sticker 实例的时候注意不要遗漏必要的传入参数。\n sticker_info \n如何回复指定的消息 简单来说这就是一个套娃过程，从包含关键字消息的 reply_to_message 成员可以判断并拿到上一条回复的消息，回复拿到的上一条消息即可，从而实现精准打击（x\n... msg = update.message.reply_to_message if msg is not None: msg.reply_sticker(sticker) ...  reply to your reply \n结束 以简单的案例来介绍 Telegram 机器人的玩法，希望能够帮助到入门的萌新打造属于自己的机器人。（撒花 ~=o(^▽^)o~♪\n","date":"2020-12-31T17:26:38+08:00","image":"https://axionl.me/p/%E6%96%B0%E6%89%8B%E7%AF%87-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E8%86%9B%E6%9C%BA%E5%99%A8%E4%BA%BA/banner_hu4f5eb48d6a6112537f077a0440a251a0_96293_120x120_fill_box_smart1_3.png","permalink":"https://axionl.me/p/%E6%96%B0%E6%89%8B%E7%AF%87-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E8%86%9B%E6%9C%BA%E5%99%A8%E4%BA%BA/","title":"[新手篇] 如何写一个简单的上膛机器人"},{"content":"简介 常用于跨平台集群管理，提供多设备认证、远程操作和反向代理。\n 项目地址：github.com/gravitational/teleport\n  官方网站：goteleport.com\n 安装 有以下几种方式，单个可执行文件内已经包含 web 管理平台、服务端和客户端功能。(Windows 目前仅支持客户端)\n 可执行文件下载 Docker 下载 编译安装  快速配置 服务端及 Web 管理平台 teleport:data_dir:/var/lib/teleport# 数据存放目录auth_service:enabled:truecluster_name:\u0026#34;demo_cluster\u0026#34;listen_addr:0.0.0.0:3025# 认证监听地址tokens:- proxy,node,app:\u0026lt;nodes_auth_token\u0026gt;# 节点认证密令ssh_service:enabled:truelabels:env:stagingapp_service:enabled:truedebug_app:falseproxy_service:enabled:truelisten_addr:0.0.0.0:3023# 反向代理监听地址web_listen_addr:0.0.0.0:3080# web 管理页面地址tunnel_listen_addr:0.0.0.0:3024# 隧道监听地址public_addr:\u0026lt;https://example.domain.org:3025\u0026gt;# 反向代理公共地址https_keypairs:# 本地测试时可不设置证书- key_file:\u0026lt;key_file_path\u0026gt;- cert_file:\u0026lt;cert_file_path\u0026gt;可由如下命令启用服务端进行测试，要点如下:\n 在本地测试时即便没有填写 https_keypairs 也仍然需要在监听的 web 地址前面加上 https://，或者使用 --insecure-no-tls 命令行参数对 http:// 进行访问。 如果配置中含有非对应权限目录或者证书文件，则调整到对应权限，如 /var/lib/teleport 仅限 root 权限访问，则需要调整到对应的权限再启动命令。 所有的登陆行文均在 web_listen_addr 所指示的地址发生。 注意证书所对应的域名与可访问的相同  $ teleport start --config teleport.yaml tctl 是 teleport 的一个命令行管理工具，在 teleport 服务运行时，可以由它对用户、节点、密令等进行动态管理。\n# 创建一个初始用户 $ tctl users add \u0026lt;username\u0026gt; \u0026lt;login_user, login_group\u0026gt; --config teleport.yaml 添加好用户后可访问提示的地址，输入账户密码，用手机两步验证器扫码后填入验证码即可初始化成功。配置文件中支持除 otp 外还支持 github auth 认证等方式。\n 注册界面   登陆界面 \n 常用的两步验客户端\n Authy Google Authenticator Microsoft Authenticator   子节点 除了服务端平台自己可以作为节点外，还可以添加其他的子节点构成集群，大体上分为两类：\n 子节点有公网可以访问 非公网节点需要反向代理(roles 内需要含有 proxy)。  静态子节点 静态子节点配置文件需要对应服务端里的地址和 \u0026lt;nodes_auth_token\u0026gt;，随后直接在节点上运行即可。\nteleport:nodename:\u0026#34;my_laptop\u0026#34;data_dir:/var/lib/teleport/auth_token:\u0026lt;nodes_auth_token\u0026gt;auth_servers:- \u0026lt;https://example.domain.org:3025\u0026gt;# 认证地址proxy_service:enabled:false# 本地子节点暂时无需启动反向代理服务端ssh_service:enabled:truelabels:env:local_nodeauth_service:enabled:false# 本地子节点暂时无需启动认证服务端动态子节点 动态子节点需要在服务端上进行添加，由以下命令生成一个临时的 token 以添加子节点。\n$ tctl nodes add --roles=node,proxy --ttl=5m --config teleport.yaml 得到形如下方的命令：\n$ teleport start \\  --roles=node,proxy \\  --token=\u0026lt;random_token\u0026gt; \\  --auth-server=\u0026lt;https://example.domain.org:3025\u0026gt; 添加成功后可以在 web 界面内看到所有的节点。  Server Page \n客户端 安装包内自带一个名为 tsh 的可执行文件，用于命令行认证和登陆\n$ tsh login --proxy=\u0026lt;https://example.domain.org:3025\u0026gt; --user=\u0026lt;username\u0026gt; 登陆后可以使用 ls 命令查看已添加的节点\n$ tsh ls Node Name Address Labels -------------- -------------- ---------------- demo_cluster 127.0.0.1:3022 env=core_service my_laptop ⟵ Tunnel env=local_node 使用 ssh 来登陆节点终端\n$ tsh ssh \u0026lt;node_name\u0026gt; 高级配置 配合 K8S 管理服务 TBC\u0026hellip;\n  Banner Artwork\n ","date":"2020-12-06T23:04:45+08:00","image":"https://axionl.me/p/teleport-%E5%B0%8F%E8%AE%B0/banner_hu1e0fdfd11adc7a773716bb21146059e6_715126_120x120_fill_q75_box_smart1.jpg","permalink":"https://axionl.me/p/teleport-%E5%B0%8F%E8%AE%B0/","title":"Teleport 小记"}]